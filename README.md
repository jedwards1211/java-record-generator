# java-record-generator

[![Build Status](https://travis-ci.org/jedwards1211/java-record-generator.svg?branch=master)](https://travis-ci.org/jedwards1211/java-record-generator)
[![Coverage Status](https://coveralls.io/repos/github/jedwards1211/java-record-generator/badge.svg?branch=master)](https://coveralls.io/github/jedwards1211/java-record-generator?branch=master)

I created this for my own personal use.  If you want more information about how to use it, feel free to open an issue.

## Quick Start

```
npm i -g java-record-generator
cd path/to/your/java/project
java-record-generator
```

`java-record-generator` watches `**/*.record.js` files inside your project and automatically generates `.java` files
with the corresponding name based upon the configuration in the `.record.js` files.

## Why is this written in JS and not Java?

Because this is way easier to write with ES6 template strings, `chokidar` file watching, etc. than with Java.

## Example config:

`src/main/java/org/breakout/model/SurveyTrip.record.js`:

```es6
module.exports = {
	imports: [
	  'java.util.List',
	  'java.util.Date',
	  'org.andork.unit.Unit',
	  'org.andork.unit.Angle',
	  'org.andork.unit.Length',
	],
	generateProperties: true,
	generateSetters: true,
	generateUpdaters: true,
	fields: {
		cave: {type: 'String', description: 'cave name'},
		name: {type: 'String', description: 'trip name'},
		date: {type: 'Date', description: 'trip date'},
		surveyNotes: {type: 'String', description: 'survey notes file path'},
		surveyors: {type: 'List<String>', description: 'surveyor names'},
		distanceUnit: {type: 'Unit<Length>', description: 'default length unit', initValue: 'Length.meters'},
		angleUnit: {type: 'Unit<Angle>', description: 'default angle unit', initValue: 'Angle.degrees'},
		overrideFrontAzimuthUnit: {type: 'Unit<Angle>', description: 'default frontsight azimuth unit'},
		overrideBackAzimuthUnit: {type: 'Unit<Angle>', description: 'default backsight azimuth unit'},
		overrideFrontInclinationUnit: {type: 'Unit<Angle>', description: 'default frontsight inclination unit'},
		overrideBackInclinationUnit: {type: 'Unit<Angle>', description: 'default backsight inclination unit'},
		backAzimuthsCorrected: {
			type: 'boolean',
			description: 'whether backsight azimuths are corrected',
			getterName: 'areBackAzimuthsCorrected',
		},
		backInclinationsCorrected: {
			type: 'boolean',
			description: 'whether backsight inclinations are corrected',
			getterName: 'areBackInclinationsCorrected',
		},
		declination: {type: 'String', description: 'magnetic declination'},
		distanceCorrection: {type: 'String', description: 'correction for shot distances'},
		frontAzimuthCorrection: {type: 'String', description: 'correction for frontsight azimuths'},
		frontInclinationCorrection: {type: 'String', description: 'correction for frontsight inclinations'},
		backAzimuthCorrection: {type: 'String', description: 'correction for backsight azimuths'},
		backInclinationCorrection: {type: 'String', description: 'correction for backsight inclinations'},
	}
}
```

## Example generated class:

```java
/**
 * Generated by java-record-generator on 11/27/2016, 4:47:02 PM.
 * {@link https://github.com/jedwards1211/java-record-generator#readme}
 */

package org.breakout.model;

import java.util.List;
import java.util.Date;
import org.andork.unit.Unit;
import org.andork.unit.Angle;
import org.andork.unit.Length;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.Objects;
import org.andork.model.DefaultProperty;
import java.util.function.BiConsumer;

/**
 *
 */
public class SurveyTrip {

	public static class SurveyTripProperty<V> extends DefaultProperty<SurveyTrip, V> {
		private final BiConsumer<MutableSurveyTrip, ? super V> setter;

		public SurveyTripProperty(String name, Class<? super V> valueClass,
				Function<? super SurveyTrip, ? extends V> getter, BiConsumer<MutableSurveyTrip, ? super V> setter) {
			super(name, valueClass, getter);
			this.setter = setter;
		}

		public MutableSurveyTrip set(MutableSurveyTrip trip, V newValue) {
			setter.accept(trip, newValue);
			return trip;
		}
	}

	public static class Properties {

		/**
		 * cave name
		 */
		public static final SurveyTripProperty<String> cave = new SurveyTripProperty<String>(
			"cave",
			String.class,
			r -> r.getCave(),
			(m, v) -> m.setCave(v)
		);

        ...

	}

	public static class MutableSurveyTrip implements Cloneable {
		private int modCount = 0;

		/**
		 * cave name.
		 */
		private String cave;

        ...


		/**
		 * @return cave name.
		 */
		public String getCave() {
			return cave;
		}

        ...

		/**
		 * Sets cave name.
		 *
		 * @param cave - the new value for cave name
		 *
		 * @return this {@code MutableSurveyTrip}.
		 */
		public MutableSurveyTrip setCave(String cave) {
			if (Objects.equals(this.cave, cave)) return this;
			modCount++;
			this.cave = cave;
			return this;
		}

	    ...

		/**
		 * Updates cave name.
		 *
		 * @param updater - {@code Function} that takes the current value of {@code cave} and returns the new value for {@code cave}.
		 *
		 * @return this {@code SurveyTrip} if {@code cave} is unchanged, or a copy with the updated {@code cave}.
		 */
		public MutableSurveyTrip updateCave(Function<String, String> updater) {
			return setCave(updater.apply(cave));
		}

		...

		@Override
		public MutableSurveyTrip clone() {
			try {
				return (MutableSurveyTrip) super.clone();
			} catch (Exception e) {
				// should not happen
				throw new RuntimeException(e);
			}
		}
	}

	private final MutableSurveyTrip data;

	private SurveyTrip(MutableSurveyTrip data) {
		this.data = data;
	}

	public SurveyTrip() {
		this(new MutableSurveyTrip());
	}

	public boolean equals(Object o) {
		return o == this;
	}

	/**
	 * @param initializer a {@link Consumer} that initializes a {@code SurveyTrip}.
	 *
	 * @return a new {@code SurveyTrip} with values initialized by {@code initializer}.
	 */
	public static SurveyTrip create(Consumer<MutableSurveyTrip> initializer) {
		MutableSurveyTrip data = new MutableSurveyTrip();
		initializer.accept(data);
		return new SurveyTrip(data);
	}

	/**
	 * @param mutator a {@link Consumer} that applies mutations to this {@code SurveyTrip}.
	 *
	 * @return a copy of this {@code SurveyTrip} with the given mutations applied.
	 */
	public SurveyTrip withMutations(Consumer<MutableSurveyTrip> mutator) {
		MutableSurveyTrip newData = data.clone();
		mutator.accept(newData);
		return newData.modCount == data.modCount ? this : new SurveyTrip(newData);
	}


	/**
	 * @return cave name.
	 */
	public String getCave() {
		return data.cave;
	}

    ...


	/**
	 * Sets cave name.
	 *
	 * @param cave - the new value for cave name
	 *
	 * @return this {@code SurveyTrip} if {@code cave} is unchanged, or a copy with the new {@code cave}.
	 */
	public SurveyTrip setCave(String cave) {
		if (Objects.equals(data.cave, cave)) return this;
		return new SurveyTrip(data.clone().setCave(cave));
	}

    ...

	/**
	 * Updates cave name.
	 *
	 * @param updater - {@code Function} that takes the current value of {@code cave} and returns the new value for {@code cave}.
	 *
	 * @return this {@code SurveyTrip} if {@code cave} is unchanged, or a copy with the updated {@code cave}.
	 */
	public SurveyTrip updateCave(Function<String, String> updater) {
		return setCave(updater.apply(data.cave));
	}

	...

}
```